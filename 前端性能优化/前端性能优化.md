# 前端性能优化

## 资源合并与压缩

> web前端本质上就是一种 **GUI软件** .

### 浏览器的一个请求从发送到返回都经历了什么?

![](./img/请求流程.png)

#### 本地层面的优化

1. 缓存dns, 减少查询时间 .
2. 在服务端进行HTML渲染 .

#### 网络层面优化

1. 静态资源可以放在CDN, 直接请求最近的网络环境, 注意, CDN域名避免与主站相同, 这样可以不用携带主站cookie, 可以略微减少网络开销 . 
2. 减少http请求的大小和次数 .

### 资源的合并与压缩

#### HTML压缩

1. 删除空格, 回车, 制表符等没有意义的字符.
2. 删除注释.

##### 如何进行HTML压缩

1. node.js的 **html-minifier** .
2. 后端模版引擎渲染压缩 .

#### CSS压缩

1. 删除无效代码 .
2. css语义合并 .
3. 去掉回车和空格 .

##### 如何进行CSS压缩

1. node.js的 **html-minifier** .
2. **clean-css** . 

#### JS压缩与混乱

1. 删除无效字符和注释 .
2. 代码语义的缩减和优化 .
3. 代码保护 .

##### 如何进行JS的压缩与混乱

1. **html-minifier** .
2. **uglifyjs2** .

#### 文件合并

![](./img/文件合并.png)

##### 文件合并存在的问题

- 首屏渲染问题: 文件体积增大, 如果极度依赖js文件的网页, 会等js文件完全加载完毕才渲染网页, 这样, 会白屏很长时间 .
- 缓存失效问题:  浏览器缓存js文件, 会带一个md5的戳, 当你讲多个js文件合并成一个大的js文件后, 但凡一点点改动, 浏览器都会重新加载整个大的js文件, 继而缓存失效, 如果不合并, 就只会加载某一个被改变的js, 剩下的都可以从缓存里取 .

基于上述条件, 我们合并的文件, 主要选择公共库, 不同的页面进行合并(SPA) .

## 图片相关优化

### CSS雪碧图

- 减少HTTP请求数量 .
- 图片较大时, 一次加载比较慢 .

### Image inline

> 将图片的内容内嵌到html当中, 当做一个base-64的格式, 可以减少HTTP请求数量, 常用于体积比较小的图片 .

## CSS和JS的装载与执行

![](img/html页面加载渲染的过程.png)

### HTML加载渲染的特点

- 顺序执行, 并发加载 (css和js等资源, 并发度收到域名的限制, 一般静态资源会放置在 三到四个 CDN域名 的服务器上.)
- 是否阻塞
- 依赖关系 
- 引入方式

#### CSS阻塞

> **css** 在 **head** 中通过 **link** 标签的引入, 会阻塞页面渲染, 推荐, 这样, 用户看到的页面是一个具有样式的页面 .
>
> **css** 放在 **body** 中不会阻塞页面的渲染, 如果网络环境恶劣, 用户会看到没有样式的页面, 等 **css** 加载完成后, 才能看到有样式的页面 .
>
> **css** 在加载的过程中, 会阻塞 **JS** 的执行 , 但是不会阻塞 **JS** 的加载 .

####JS阻塞

> 直接引入(通过 script src 的方式引入)的 **JS** 会阻塞页面渲染 .
>
> **JS** 不阻塞资源的加载 .
>
> **JS** 顺序执行, 阻塞后续 **JS** 逻辑的执行 .

#### 依赖关系

> 页面渲染依赖于 **CSS** 的加载 .
>
> **JS** 的执行顺序的依赖关系 .
>
> **JS** 逻辑对于 **dom** 节点的依赖关系 .

#### JS引入方式

##### 直接引入

> 会阻塞页面的渲染 .
>
> 传统的引入方式 .

```html
<script src:"./main.js"></script>
```

##### defer

> 不会阻塞页面的渲染 .
>
> 执行 **defer** 的时候, **dom** 树一定已经构建完成了 .
>
> **defer** 的执行顺序, 也是由上至下, 顺序执行的 .
>
> 这种方式, 必定能获取dom元素, 即便在**head** 中引入, 也能获取到  .

```html
<script src:"./main.js" defer></script>
```

##### async

> 不会阻塞页面的渲染 .
>
> **async** 不保证执行顺序, 所以, 通过这种方式引入的脚本, 一般都是没有相互依赖关系的 , 谁先加载完毕, 谁先执行 .
>
> 不一定能获取到 dom元素 , 这个脚本加载完成时, dom树有可能还没构建完成 .

```html
<script src:"./main.js" async></script>
```

##### 异步动态引入JS

> 当需要使用某个 **JS** 文件时, 动态创建 **script** 标签引入 .

```javascript
// 当这个函数执行时, 才会去发起请求加载这个js文件
function loadScript(url) {
    let script = document.createElement('script')
    script.type = 'text/javascript'
    script.src = url
    document.body.appendChild(script)
}
```

### 加载和执行的优化点

- CSS样式表置顶 .
- 用 link 代替 @import(这种方式不会触发浏览器并发加载机制, 现代浏览器貌似已经解决了这个问题, 在合适的地方使用 @import, 可以通过模块化的方式更好的维护 css样式) .
- JS 脚本置底 .
- 合理使用 JS 的异步加载能力 .

## 懒加载与预加载

###懒加载

- 图片进入可视区域后请求图片资源 .
- 对于电商等图片很多, 页面很长的业务场景适用 .
- 减少无效的资源的加载 .
- 并发加载的资源过多会阻塞 **JS** 的加载, 影响网站的正常使用 .

> img 标签 上的 src 是个占位符, 一旦设置了, 就会按照地址去请求图片, 所以, 懒加载的原理就是, 当这个 img 标签 进入可视区域后, 再设置 src .

#### 实现

> 监听 **scroll** 事件, 当 **img** 进入可视区域时, 修改 **src** .
>
> 需要知道可视区域的 **height** , 需要知道 **img** 标签的 **top** 值 .
>
> 当 **top** 小于 **height** 的时候, 修改 **src** 即可 .

各类框架都有相应的, lazyload.js 的库 .

###预加载

- 图片等静态资源在使用之前提前请求 .
- 资源使用到时能从缓存中加载, 提升用户体验 .
- 页面展示的依赖关系维护 .

> 与懒加载相反, 提前加载所需文件, 

#### 实现

第一种, 设置一个 `display:none;`  的 img标签, 直接把图片加载进来, 放在缓存中 .

第二种, 使用 Image 对象, 去请求图片链接 , 讲图片放在缓存中 .

```javascript
let image = new Image()
image.src = 'http://path'
```

第三种, ajax请求, 缺点, 跨域 , 优点, 可以控制预加载的整个过程 .

第四种, preload.js, 一个很好用的预加载库, 可以加载各种多媒体资源 .

## 重绘与回流

**css性能会让javascript变慢**

> 频繁触发**重绘**与**回流**, 会导致UI频繁渲染, 最终导致JS变慢 .

### 回流

- 当 `render tree` 中的一部分(或全部)因为元素的规模尺寸, 布局, 隐藏等改变而需要重新构建. 这就称为回流(reflow) .
- 当页面布局和几何属性改变时就需要回流 .